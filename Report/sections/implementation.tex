\section{Implementation}
The following section describes the core components of the {\dhr} implementation.

\subsection{Term Expansion}

The {\dhr} library creates a rule for every declared constraint (see \ref{sec:rule_def}).
An example program containing the declaration \inlineCode{:- chr_constraint a/0.} would result in an expanded program containing the rule \inlineCode{a :- chr_solve(a, _), !.}\\
The \inlineCode{chr_solve} rule acts as an entry point to the chr program evaluation.
It will be called for every entry in the constraint store.
The rule creates an initial \inlineCode{chr_state} and triggers the processing of that state.

\subsection{Program Evaluation}

The {\dhr} library processes the current \inlineCode{chr_state} via two possible state transitions \inlineCode{chr_apply} and \inlineCode{chr_cont}.

\subsubsection*{chr_apply}

This transition will attempt to find an applicable rule given the current \inlineCode{chr_state}.
A rule counts as applicable if the head of the rule can be matched with the constraint store or a subset thereof.\\
If such a rule is found it will be reset.
The result (\inlineCode{Ball}) will be added to the constraint store and set as the active constraint and the head constraints on the right side of the generalized simpagation rule will be removed from the constraint store.\\
If no such rule could be found the \inlineCode{chr_apply} rule will delegate the processing of the \inlineCode{current_state} to the \inlineCode{chr_cont} rule.

\subsubsection*{chr_cont}

The \inlineCode{chr_cont} transition discards completed continuations, which are denoted by a 0, from the top of the continuation stack within the input \inlineCode{chr_state}.
When the top most continuation is not completed, the whole continuation stack, which is represented by a conjunction of continuations, is reset.
Should the continuation stack return a result, said result will be added to the constraint store and the active constraint of the output state will also be set to the resulting constraint.
At the same time the resulting continuation is inserted as the new continuation stack within the output \inlineCode{chr_state}.

\subsection{Matching}

In order to evaluate whether a rule is applicable, given the current constraint store, a matching algorithm had to be implemented.
Matching in CHR can be thought of as a one-sided unification, meaning that terms may only be unified if the constraint, from the constraint store, is more or equaly specific (i.e. further or equaly instantiated) than the corrosponding constraint from the rule head.
The SWI-Prolog environment offers a predicate \inlineCode{subsumes_term(@Generic, @Specific)} that can decide whether or not a term is more generic than another term.
As the documentation states ''True if Generic can be made equivalent to Specific by only binding variables in Generic. The current implementation performs the unification and ensures that the variable set of Specific is not changed by the unification. On success, the bindings are undone.''~\cite{swipl:doc:subsumes_term} the two terms are not being unified upon comparison.
Instead a unifier is built while the term is being examined for aplicability, by recursing through the term parameters until both sides consist of atomic, or single variable, values.
Said unifier is executed before the rule is reset.
The following listing illustrates the key aspects of the unifier construction.

\begin{lstlisting}[frame=single, caption=excerpt of the code constructing the unifier for two structurally equivilant terms, label={lst:unif}]
combine_unifiers(NewUnifier, UnifierAcc, CombinedUnifier) :-
    NewUnifier = (Head-Store),
    var(Head),
    member_unifier_safe((Head-_), UnifierAcc, Result),
    Result = (_-R), Store == R,
    CombinedUnifier = UnifierAcc.

combine_unifiers(NewUnifier, UnifierAcc, CombinedUnifier) :-
    NewUnifier = (Head-_),
    var(Head),
    \+(member_unifier_safe((Head-_), UnifierAcc, _)),
    CombinedUnifier = [NewUnifier|UnifierAcc].

combine_unifiers(NewUnifier, UnifierAcc, CombinedUnifier) :-
    NewUnifier = (Head-Store),
    nonvar(Head),
    Head =.. [_|NewHeads],
    Store =.. [_|NewStores],
    combine_unifiers(NewHeads, NewStores,
            UnifierAcc, CombinedUnifier).
\end{lstlisting}

\noindent An important task of the listed code is to make sure that variables may onle be unified to one other term.
Meaning that a variable \inlineCode{A} may not be unified with for example another variable \inlineCode{B} and an atom \inlineCode{a}.



\newpage